% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bernoulliTBSS.R
\name{bernoulliTBSS}
\alias{bernoulliTBSS}
\title{Bernoulli TBSS}
\usage{
bernoulliTBSS(
  case,
  control,
  tree,
  p = 1/2,
  min_events = 2,
  B = 999,
  parallel = FALSE,
  ncpus = NULL,
  type = "unconditional",
  nodeToRemove = NULL,
  seed = 8277
)
}
\arguments{
\item{case}{a \code{matrix} or \code{data.frame} with two columns (leavesID, cases). Here cases indicate the number of events in the treated group.}

\item{control}{a \code{matrix} or \code{data.frame} with two columns (leavesID, controls). Here control indicates the number of events in the untreated group.}

\item{tree}{a \code{matrix} or \code{data.frame} with two columns (nodeID, parentID) that specifies the hierarchical structure in an edge list format.}

\item{p}{a number in (0,1) indicating the probability of being associated with the treated group under the null hypothesis that treated and untreated have the same probability of experiencing an event. When \code{type = "variableMR"}, this has to be specified in case and control matrices. See details for more information.}

\item{min_events}{the minimum number of observed events for a node to be tested. This is an integer greater or equal to 2. Default \code{min_events = 2}. Note that by choosing higher \code{min_events}, the power can increase because of the decreased number of hypotheses that are tested. This argument should be fixed before running the analysis to preserve the validity of the p-values.}

\item{B}{number of Monte Carlo replicates. The default is \code{B = 999}.}

\item{parallel}{if \code{parallel = TRUE} parallel computing is used to compute the Monte Carlo p-values.}

\item{ncpus}{number of cpus used if \code{parallel = TRUE}. If no value is provided, the default is \code{ncpus = detectCores() - 1}.}

\item{type}{determines the type of Bernoulli TBSS to perform. Possible values are \code{type = "unconditional"} for unconditional Bernoulli TBSS, \code{type = "conditional"} for TBSS conditional to the total number of events in the tree, and  \code{type = "variableMR"} for variable matching ratios TBSS (see Details). Default is \code{type = "unconditional"}.}

\item{nodeToRemove}{a character vector with user-specified nodes to be removed from the analysis.  Note that sufficient statistics for these nodes are computed, but they are excluded from the testing procedure. By removing nodes from the list of tests, power can increase because of the decreased number of hypotheses that are tested. This list should be specified before running the analysis.}

\item{seed}{a number indicating the seed used for the analysis, i.e., the input of \code{set.seed()}. Default \code{seed  = 8277}.}
}
\description{
This function implements a variety of  Bernoulli TBSS, including stratified analysis that can be used with matched data with variable matching ratios.
}
\details{
In TBSS, analyzing matched data with a variable matching ratio requires specifying a different \eqn{p} for each matched set. Typically, we have a length-\eqn{M} vector \eqn{(p_1, \ldots,p_M)} corresponding to \eqn{m:1} matched sets with \eqn{p_m = 1/(1+m)} for \eqn{m=1,\ldots,M.} Note that the same logic applies to any stratified analysis where the \eqn{M} sets are strata, and \eqn{p_m} is the probability of being associated with the untreated group under the null hypothesis. An example of how data are formatted for this analysis is provided in the examples.
}
\examples{
## Unconditional Bernoulli TBSS examples
library(dplyr)
library(TBSS)

# load tree 
data("tree_example", package = 'TBSS')

# load data
data("bernoulli_TBSS_examples", package = 'TBSS')

#treated group
data_treated = bernoulli_TBSS_examples$fixed_matching_ratio$case
head(data_treated)

# control group
data_untreated = bernoulli_TBSS_examples$fixed_matching_ratio$control
head(data_untreated)

matching_prob = bernoulli_TBSS_examples$fixed_matching_ratio$p

mod_tbss = bernoulliTBSS(case = data_treated,
                        control = data_untreated, 
                        tree = tree_example, 
                         p = matching_prob )
# inspect potential signals
summary(mod_tbss) |> filter(pvalue <=0.05)


## Bernoulli TBSS stratified (e.g., for matched data with variable matching ratio) 

library(dplyr)
library(TBSS)

# load tree 
data("tree_example", package = 'TBSS')

# load data
data("bernoulli_TBSS_examples", package = 'TBSS')
data_treated = bernoulli_TBSS_examples$variable_matching_ratio$case
head(data_treated)

data_untreated = bernoulli_TBSS_examples$variable_matching_ratio$control
head(data_untreated)

mod_tbss = bernoulliTBSS(case = data_treated, control = data_untreated, tree = tree_example, type ='variableMR')

# inspect potential signals
summary(mod_tbss) |> filter(pvalue <=0.05)
}
